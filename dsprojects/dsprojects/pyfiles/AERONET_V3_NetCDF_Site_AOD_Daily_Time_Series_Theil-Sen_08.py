# AERONET_V3_NetCDF_Site_AOD_Daily_Time_Series_Theil-Sen_08.py
#
# This is a Python 3.9.12 code to read the AERONET V3 NetCDF files generated by 
# the AERONET_V3_DailyAverages_AOD*_Site_2_NetCDF_* code and analyze the time series
# using a non-parametric Theil-Sen estimator and the approach described by Mortier, et al.,
# 2021, Atmospheric Chemistry and Physics as well as a Mann-Kendall test for trend
# significance.
#
# Creation Date: 2022-04-20
# Last Modified: 2022-04-20
#
# by Michael J. Garay
# (Michael.J.Garay@jpl.nasa.gov)

# Import packages

from datetime import datetime
import glob
import math
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator, FormatStrFormatter, AutoMinorLocator
from netCDF4 import Dataset
import numpy as np
import os
import time

def main():  # Main code

# Time the code

    start_time = time.time()

# Print a blank line

    print()
    
# Set the paths

    aeropath = '/Users/mgaray/Desktop/CODING/PYTHON/PY39/APR22/AERONET/DATA/'
    figpath = '/Users/mgaray/Desktop/CODING/PYTHON/PY39/APR22/AERONET/FIGS/'

# Select the AERONET site

#    site_name = 'Bakersfield'
#    site_name = 'CalTech'
#    site_name = 'Fresno_2'
#    site_name = 'Goldstone'
#    site_name = 'Mount_Wilson'
#    site_name = 'NEON_SJER'
#    site_name = 'NEON_TEAK'
#    site_name = 'Santa_Monica_Colg'
#    site_name = 'TABLE_MOUNTAIN_CA'
#    site_name = 'UCSB'
    site_name = 'USC_SEAPRISM'
#    site_name = 'Modena'
#    site_name = 'Ersa'
#    site_name = 'LAQUILA_Coppito'
#    site_name = 'Rome_La_Sapienza'
#    site_name = 'Rome_Tor_Vergata'
#    site_name = 'Napoli_CeSMA'
    
# Set the AERONET filenames

    aero_name_15 = 'AERONET_V3_DailyAverages_AOD15_'+site_name+'_2022_04_20_v04.nc'
    aero_name_20 = 'AERONET_V3_DailyAverages_AOD20_'+site_name+'_2022_04_20_v02.nc'

# Set the output filenames
  
#    outname1 = site_name+'_AOD_Seasonal_Sampling_v02.png'
    outname1 = site_name+'_AOD_Yearly_Average_Theil-Sen_v08.png'

### FIND AND READ THE AERONET Level 1.5 FILE

# Change to the data directory

    os.chdir(aeropath)

# Get the file list

    file_list = glob.glob(aero_name_15)
    
    num_files = len(file_list)

# Choose the correct file

    inputName = file_list[0]    

# Tell user location in process

    print('Reading: ',inputName)
    
# Open the NetCDF file

    rootgrp = Dataset(inputName, 'r', format='NETCDF4')
    
# Read the data
    
    year_raw = rootgrp.variables['Year'][:]
    month_raw = rootgrp.variables['Month'][:]
    day_raw = rootgrp.variables['Day'][:]
            
    aod_raw = rootgrp.variables['AOD_550nm'][:]
    
# Close the NetCDF file

    rootgrp.close()
    
# Convert AERONET data to numpy arrays for analysis

    aero_year_15 = np.array(year_raw)
    aero_month_15 = np.array(month_raw)
    aero_day_15 = np.array(day_raw)
            
    aero_aod_15 = np.array(aod_raw)
    
# Generate the appropriate time string format

    time_raw = []

    num_found = len(aero_year_15)
    
    for i in np.arange(num_found):
    
        time_str = "{:}-".format(int(aero_year_15[i]))
        time_str = time_str+"{:02}-".format(int(aero_month_15[i]))
        time_str = time_str+"{:02}".format(int(aero_day_15[i]))
        base_time = time_str  
        
        time_str = base_time+"T12:00:00"  # Set to 12:00:00  
        
# Store the time string

        time_raw.append(time_str)

# Convert the date string to a numpy array

    aero_dates_15 = np.array(time_raw,dtype='datetime64[m]')
    
### FIND AND READ THE AERONET Level 2.0 FILE

# Get the file list

    file_list = glob.glob(aero_name_20)
    
    num_files = len(file_list)

# Choose the correct file

    inputName = file_list[0]    

# Tell user location in process

    print('Reading: ',inputName)
    
# Open the NetCDF file

    rootgrp = Dataset(inputName, 'r', format='NETCDF4')
    
# Read the data
    
    year_raw = rootgrp.variables['Year'][:]
    month_raw = rootgrp.variables['Month'][:]
    day_raw = rootgrp.variables['Day'][:]
            
    aod_raw = rootgrp.variables['AOD_550nm'][:]
    
# Close the NetCDF file

    rootgrp.close()
    
# Convert AERONET data to numpy arrays for analysis

    aero_year_20 = np.array(year_raw)
    aero_month_20 = np.array(month_raw)
    aero_day_20 = np.array(day_raw)
        
    aero_aod_20 = np.array(aod_raw)
    
# Generate the appropriate time string format

    time_raw = []

    num_found = len(aero_year_20)
    
    for i in np.arange(num_found):
    
        time_str = "{:}-".format(int(aero_year_20[i]))
        time_str = time_str+"{:02}-".format(int(aero_month_20[i]))
        time_str = time_str+"{:02}".format(int(aero_day_20[i]))
        base_time = time_str  
        
        time_str = base_time+"T12:00:00"  # Set to 12:00:00  

# Store the time string

        time_raw.append(time_str)

# Convert the date string to a numpy array

    aero_dates_20 = np.array(time_raw,dtype='datetime64[m]')

### EXTRACT THE NUMBER OF UNIQUE YEARS

# Calculate the mean, median, and mode optical depth

    print("********")
    print(site_name)

# Print the number of days

    print("NUMBER OF DAYS")
    print("LEV1.5:",len(aero_aod_15))
    print("LEV2.0:",len(aero_aod_20))

# Get the number of unique years

    unique_years_15 = np.unique(aero_year_15)
    num_years_15 = len(unique_years_15)
    unique_years_20 = np.unique(aero_year_20)
    num_years_20 = len(unique_years_20)
    print("NUMBER OF YEARS")
    print("LEV1.5:",num_years_15)
    print(unique_years_15)
    print("LEV2.0:",num_years_20)
    print(unique_years_20)   
    
### Loop through the years and months and report the sampling
# NOTE: There may be missing years or months

    min_years = 2000  # Set the minimum year
    max_years = 2022  # Set the maximum year
    
    num_years = max_years-min_years+1

# Set arrays to store the results

    month_count_15 = np.zeros((num_years,12))
    month_good_15 = np.zeros((num_years,12))
    
    season_count_15 = np.zeros((num_years,4))
    season_good_15 = np.zeros((num_years,4))
    
    month_median_15 = np.zeros((num_years,12))
    month_uq_15 = np.zeros((num_years,12))
    month_lq_15 = np.zeros((num_years,12))
    month_average_15 = np.zeros((num_years,12))
    
    season_sum_15 = np.zeros((num_years,4))
    season_average_15 = np.zeros((num_years,4))
    year_average_15 = np.zeros(num_years)

    month_count_20 = np.zeros((num_years,12))
    month_good_20 = np.zeros((num_years,12))
    
    season_count_20 = np.zeros((num_years,4))
    season_good_20 = np.zeros((num_years,4))
    
    month_median_20 = np.zeros((num_years,12))
    month_uq_20 = np.zeros((num_years,12))
    month_lq_20 = np.zeros((num_years,12))
    month_average_20 = np.zeros((num_years,12))
    
    season_sum_20 = np.zeros((num_years,4))
    season_average_20 = np.zeros((num_years,4))
    year_average_20 = np.zeros(num_years)

### Loop over the years (Lev1.5)    
    
    for i in range(num_years):
    
        this_year = i+min_years
#        print(this_year)
        
        keep_year = (aero_year_15 == this_year)    
        found_month = aero_month_15[keep_year]
        found_aod = aero_aod_15[keep_year]
        
# Loop over the months        
        
        for j in range(0,12):
            
            this_month = j+1
#            print(this_month)
            
            k = int(j/3)  # Calculate the seasonal index
            
            keep_month = (found_month == this_month)
            
            good_month_year = found_month[keep_month]
            
            num_good = len(good_month_year)
            
            month_count_15[i,j] = num_good

# Check the number of days threshold (set to 5 per Mortier et al., 2020)
            
            if(num_good >= 5):
            
                month_good_15[i,j] = 1  # Set to 1 (good)
            
                season_count_15[i,k] = season_count_15[i,k]+1  # Count as valid in season
                season_good_15[i,k] = 1  # Set to 1 (good); NOTE: Only need one valid month
                
# Calculate the AOD statistics                

                good_aod = found_aod[keep_month]  # Extract the AOD
                
                month_average_15[i,j] = np.mean(good_aod)
                month_median_15[i,j] = np.median(good_aod)
                month_uq_15[i,j] = np.percentile(good_aod,75)
                month_lq_15[i,j] = np.percentile(good_aod,25)
                
                season_sum_15[i,k] = season_sum_15[i,k]+np.mean(good_aod) # Add the monthly average

# Print the results

#    print(month_good_15)
#    print()
#    print(season_good_15) 

# Calculate the seasonal means

    denom = season_count_15
    denom[season_count_15 == 0] = 1.0
    
    season_average_15 = season_sum_15/denom
#    print(season_average_15)
    
# Calculate the yearly means

    season_check = np.sum(season_good_15,axis=1)
    year_sum = np.sum(season_average_15,axis=1)
    denom = season_check
    denom[season_check == 0] = 1.0
    year_average_15 = year_sum/denom
    year_average_15[season_check < 4] = 0
    
#    print(season_check)
#    print(year_average_15)
    
### Loop over the years (Lev2.0)    
    
    for i in range(num_years):
    
        this_year = i+min_years
#        print(this_year)
        
        keep_year = (aero_year_20 == this_year)    
        found_month = aero_month_20[keep_year]
        found_aod = aero_aod_20[keep_year]
        
# Loop over the months        
        
        for j in range(0,12):
            
            this_month = j+1
#            print(this_month)
            
            k = int(j/3)  # Calculate the seasonal index
            
            keep_month = (found_month == this_month)
            
            good_month_year = found_month[keep_month]
            
            num_good = len(good_month_year)
            
            month_count_20[i,j] = num_good

# Check the number of days threshold (set to 5 per Mortier et al., 2020)
            
            if(num_good >= 5):
            
                month_good_20[i,j] = 1  # Set to 1 (good)
            
                season_count_20[i,k] = season_count_20[i,k]+1  # Count as valid in season
                season_good_20[i,k] = 1  # Set to 1 (good); NOTE: Only need one valid month
                
# Calculate the AOD statistics                

                good_aod = found_aod[keep_month]  # Extract the AOD
                
                month_average_20[i,j] = np.mean(good_aod)
                month_median_20[i,j] = np.median(good_aod)
                month_uq_20[i,j] = np.percentile(good_aod,75)
                month_lq_20[i,j] = np.percentile(good_aod,25)
                
                season_sum_20[i,k] = season_sum_20[i,k]+np.mean(good_aod) # Add the monthly average

# Print the results

#    print(month_good_20)
#    print()
#    print(season_good_20) 

# Calculate the seasonal means

    denom = season_count_20
    denom[season_count_20 == 0] = 1.0
    
    season_average_20 = season_sum_20/denom
#    print(season_average_20)
    
# Calculate the yearly means

    season_check = np.sum(season_good_20,axis=1)
    year_sum = np.sum(season_average_20,axis=1)
    denom = season_check
    denom[season_check == 0] = 1.0
    year_average_20 = year_sum/denom
    year_average_20[season_check < 4] = 0
    
#    print(season_check)
#    print(year_average_20)
    
# Generate monthly arrays with NaNs
# NOTE: This is only for the Lev1.5 data

    month_median_nan = np.full((num_years,12),np.nan)
    month_uq_nan = np.full((num_years,12),np.nan)
    month_lq_nan = np.full((num_years,12),np.nan)
    
    good = month_median_15 > 0
    
    month_median_nan[good] = month_median_15[good]
    month_uq_nan[good] = month_uq_15[good]
    month_lq_nan[good] = month_lq_15[good]

### CALCULATE THE THEIL-SEN ESTIMATOR WITH MANN-KENDALL TEST FOR SIGNIFICANCE
# NOTE: We use the description from 
# https://blogs.sas.com/content/iml/2019/05/28/theil-sen-robust-regression.html
# Technically, we just use the Theil part of the estimator, since there
# are no repeated x-values, requiring the extension of Sen
# NOTE: The Mann-Kendall test information comes from
# https://vsp.pnnl.gov/help/vsample/design_trend_mann_kendall.htm and is
# implemented simultaneously since the pairwise comparison is needed for that statistic

    xvals_raw = np.arange(num_years)
    yvals_raw = year_average_15
    
    good = yvals_raw > 0  # Only choose years with valid data
    xvals = xvals_raw[good]
    yvals = yvals_raw[good]
    
    num_vals = len(xvals)
    
    n_choose_2 = int(num_vals*(num_vals-1)/2)
    
    slopes = np.zeros(n_choose_2)  # N choose 2 slopes
    signs = np.zeros(n_choose_2)  # The sum of this is the S statistics for M-K
    intercepts = np.zeros(num_vals)  # N intercepts

# Loop over all possible sets of pairs
    
    counter = 0
    for i in range(num_vals-1):
        for j in range(i+1,num_vals):
            x1 = xvals[i]
            x2 = xvals[j]
            y1 = yvals[i]
            y2 = yvals[j]
            slopes[counter] = (y2-y1)/(x2-x1)
            signs[counter] = np.sign(y2-y1)
            counter = counter+1
    
    ts_slope = np.median(slopes)
    
# Loop over all the points and calculate the intercepts
# NOTE: b = y-mx

    for i in range(num_vals):
        intercepts[i] = yvals[i] - ts_slope*xvals[i]
        
    ts_intercept = np.median(intercepts)
            
    print("***THEIL-SEN RESULTS***")
    print("Slope: {:.4f}".format(ts_slope))
    print("Intercept: {:.4f}".format(ts_intercept))
    
# Calculate the Mann-Kendall results

    s_stat = np.sum(signs)

    ties = (signs == 0)
    hold = signs[ties]
    num_ties = len(hold)
    
    if(num_ties < 1):
        var_s = (1.0/18.0)*(num_vals*(num_vals-1)*(2.0*num_vals+5))
    
    else:
        print("TIES!!")
        print(error)
    
    if(s_stat > 0):
        zmk = (s_stat-1.0)/np.sqrt(var_s)
    elif(s_stat == 0):
        zmk = 0
    elif(s_stat < 0):
        zmk = (s_stat+1.0)/np.sqrt(var_s)

# Calculate p-value using brute force
        
    p_val = 1.0/(2.0*np.sqrt(math.pi))*math.exp(-1.0*abs(zmk*zmk)/2.0)
    
    print()
    print("***MANN-KENDALL RESULTS***")
    print("n:",num_vals)
    print("S:",s_stat)
    print("Ties:",num_ties)
    print("Z_mk:{:.4f}".format(zmk))
    print("p-value:{:.4f}".format(p_val))
    
### PLOT THE TIME SERIES

# Change to the correct directory

    os.chdir(figpath)
      
# Set the plot area (using the concise format)

    fig, ax = plt.subplots(figsize=(6.75,4.5), dpi=120)

# Plot the yearly average values

    xvals = np.arange(num_years)
    yvals = year_average_15
#    yvals2 = year_average_20

    good = yvals > 0
    
    ax.scatter(xvals[good],yvals[good],marker='o',color='steelblue',s=20,zorder=3)
    
# Plot the monthly median values

    xvals = np.arange(num_years*12)/12.
    yvals = np.ravel(month_median_nan)
    
    ax.plot(xvals,yvals,color='skyblue')

# Plot the quantiles

    yvals1 = np.ravel(month_lq_nan) 
    yvals2 = np.ravel(month_uq_nan) 
    
    ax.fill_between(xvals,yvals1,yvals2,alpha=0.2)
    
# Plot the Theil-Sen result

    yvals = ts_slope*xvals+ts_intercept
    
    ax.plot(xvals,yvals,color='lightcoral')
    
#    ax.scatter(xvals,yvals2,marker='o',color='blue',s=10)
    
# Set the axes
        
    ax.set_xlabel("Year",size=16)
    ax.set_ylabel("AOD (550 nm)",size=16)
    
# Set the ticks

    ax.set_xlim(-1,22)  # Set for 2000 to 2022
    
    ax.set_xticks(np.arange(12)*2)
    
    xtick01 = '2000'
    xtick02 = '2002'
    xtick03 = '2004'
    xtick04 = '2006'
    xtick05 = '2008'
    xtick06 = '2010'
    xtick07 = '2012'
    xtick08 = '2014'
    xtick09 = '2016'
    xtick10 = '2018'
    xtick11 = '2020'
    xtick12 = '2022'

    ax.set_xticklabels([xtick01,xtick02,xtick03,xtick04,xtick05,xtick06,xtick07,xtick08,
        xtick09,xtick10,xtick11,xtick12])
     
# Set the title

    plt.title(site_name,size=20)
    
    plt.tight_layout()
                       
# Save the figure

    print("Saving: "+outname1)
    plt.savefig(outname1,dpi=300)
    
    plt.show()

# Print the time

    end_time = time.time()
    print("Total elapsed time was %g seconds" % (end_time - start_time))
    
# Tell user completion was successful

    print("\nSuccessful Completion\n")

### END MAIN FUNCTION


if __name__ == '__main__':
    main()